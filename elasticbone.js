// Generated by CoffeeScript 1.6.3
(function() {
  var $, Backbone, Elasticbone, _, _ref, _ref1, _ref2,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Elasticbone = {};

  $ = require('jquery');

  _ = require('backbone/node_modules/underscore');

  Backbone = require('backbone');

  Backbone.$ = $;

  Elasticbone.Backbone = Backbone;

  Elasticbone.$ = $;

  Elasticbone._ = _;

  Elasticbone.ElasticModel = (function(_super) {
    __extends(ElasticModel, _super);

    ElasticModel.prototype.urlRoot = function() {
      return "" + this.server + "/" + this.index + "/" + this.type;
    };

    function ElasticModel() {
      this.fn_get = __bind(this.fn_get, this);
      this.fn_fetch = __bind(this.fn_fetch, this);
      this.fn_save = __bind(this.fn_save, this);
      this._generate_get_handler = __bind(this._generate_get_handler, this);
      this.type = this.constructor.name;
      ElasticModel.__super__.constructor.apply(this, arguments);
    }

    ElasticModel.has = function(name, model, options) {
      var _base;
      if (options == null) {
        options = {};
      }
      options = _.defaults(options, {
        method: 'parse',
        model: model,
        name: name
      });
      (_base = this.prototype)._has || (_base._has = {});
      return this.prototype._has[name] = options;
    };

    ElasticModel.prototype.has_relationship = function(attr, options) {
      if (options == null) {
        options = {
          method: 'parse'
        };
      }
      return this._has && this._has[attr] && options.method === this._has[attr].method;
    };

    ElasticModel.prototype.get_relationship = function(attr) {
      return this._has[attr];
    };

    ElasticModel.prototype.get_relationship_model = function(attr) {
      return this.get_relationship(attr).model;
    };

    ElasticModel.prototype.get_relationship_method = function(attr) {
      return this.get_relationship(attr).method;
    };

    ElasticModel.prototype.get_relationships = function(options) {
      var key, rels, val, _ref;
      if (options == null) {
        options = {};
      }
      if (!this._has) {
        return [];
      }
      rels = [];
      _ref = this._has;
      for (key in _ref) {
        val = _ref[key];
        if (val.method === options.method) {
          rels.push(val);
        }
      }
      return rels;
    };

    ElasticModel.prototype.get = function(attr, options) {
      var data, m, rev;
      data = ElasticModel.__super__.get.call(this, attr);
      if (!data && this.has_relationship(attr, {
        method: 'fetch'
      })) {
        rev = this._has[attr].reverse;
        m = new this._has[attr].model();
        m.set_reverse(rev, this);
        m.fetch(options);
        return m;
      }
      return data;
    };

    ElasticModel.prototype.parse = function(data, options) {
      var parsed, val, _i, _len, _ref;
      data = ElasticModel.__super__.parse.apply(this, arguments);
      parsed = {};
      if (data._id) {
        parsed.id = data._id;
      }
      if (data.id) {
        parsed.id = id;
      }
      if (data.ok) {
        return parsed;
      }
      if (data._source) {
        parsed = _.extend(parsed, data._source);
      } else {
        parsed = _.extend(parsed, data);
      }
      _ref = this.get_relationships({
        method: 'parse'
      });
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        val = _ref[_i];
        parsed[val.name] = new val.model(parsed[val.name], {
          parse: true
        });
      }
      return parsed;
    };

    ElasticModel.prototype.toJSON = function(options) {
      var json, key, val, _ref;
      json = ElasticModel.__super__.toJSON.apply(this, arguments);
      delete json.id;
      if (this._has) {
        _ref = this._has;
        for (key in _ref) {
          val = _ref[key];
          if (val.method === 'parse') {
            json[key] = this.get(key).toJSON(options);
          }
        }
      }
      return json;
    };

    ElasticModel.prototype._generage_handler = function(cb) {
      var handler;
      return handler = {
        success: function(model, res, options) {
          console.log('successful', model);
          return cb(null, model);
        },
        error: function(model, xhr, options) {
          console.log('error', model, xhr, options);
          return cb(xhr, model);
        }
      };
    };

    ElasticModel.prototype._generate_get_handler = function(cb, attr) {
      var handler,
        _this = this;
      return handler = {
        success: function(model, res, options) {
          var rev;
          console.log('successful', model, _this);
          _this.set(attr, model);
          rev = _this._has[attr].reverse;
          if (rev) {
            if (model.models) {
              _.map(model.models, function(m) {
                return m.set(rev, _this);
              });
            } else {
              model.set(rev, _this);
            }
          }
          return cb(null, model);
        },
        error: function(model, xhr, options) {
          console.log('error', model, xhr, options);
          return cb(xhr, model);
        }
      };
    };

    ElasticModel.prototype.fn_save = function() {
      var _this = this;
      return function(cb) {
        return _this.save({}, _this._generage_handler(cb));
      };
    };

    ElasticModel.prototype.fn_fetch = function() {
      var _this = this;
      return function(cb) {
        return _this.fetch(_this._generage_handler(cb));
      };
    };

    ElasticModel.prototype.fn_get = function(attr) {
      var _this = this;
      return function(cb) {
        return _this.get(attr, _this._generate_get_handler(cb, attr));
      };
    };

    ElasticModel.prototype.set_reverse = function(attr, model) {
      return this.set(attr, model);
    };

    return ElasticModel;

  })(Backbone.Model);

  Elasticbone.ElasticCollection = (function(_super) {
    __extends(ElasticCollection, _super);

    function ElasticCollection() {
      _ref = ElasticCollection.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    ElasticCollection.prototype.fetch_query = function() {
      return {
        "query": {
          "match_all": {}
        }
      };
    };

    ElasticCollection.prototype.url = function() {
      var u;
      u = "" + this.server;
      if (this.index) {
        u += "/" + this.index;
        if (this.type) {
          u += "/" + this.type;
        }
      }
      u += "/_search?size=100";
      return u;
    };

    ElasticCollection.prototype.model = Elasticbone.ElasticsearchObject;

    ElasticCollection.prototype.server = 'http://localhost:9200';

    ElasticCollection.prototype.parse = function(data) {
      console.log('parse col', data);
      this.total = data.hits.total;
      this.took = data.took;
      return data.hits.hits;
    };

    ElasticCollection.prototype.fetch = function(options) {
      console.log('fetch col', options, this.fetch_query());
      return ElasticCollection.__super__.fetch.call(this, _.defaults(options, {
        type: 'POST',
        data: JSON.stringify(this.fetch_query())
      }));
    };

    ElasticCollection.prototype.set_reverse = function(attr, model) {
      return this[attr] = model;
    };

    return ElasticCollection;

  })(Backbone.Collection);

  Elasticbone.ElasticsearchType = (function(_super) {
    __extends(ElasticsearchType, _super);

    function ElasticsearchType() {
      _ref1 = ElasticsearchType.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return ElasticsearchType;

  })(Backbone.Model);

  Elasticbone.GeoShape = (function(_super) {
    __extends(GeoShape, _super);

    function GeoShape() {
      _ref2 = GeoShape.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    GeoShape.prototype.query_inside = function(server, index, type, es) {
      var ne;
      ne = new Elasticbone.ElasticsearchObjects();
      console.log(this);
      ne.elastic(this.parent._es);
      ne.fetch_query = {
        "query": {
          "filtered": {
            "query": {
              "field": {
                "_geojson_dataset": "\"nz-area-units\""
              }
            },
            "filter": {
              "geo_shape": {
                "geometry": {
                  "indexed_shape": {
                    "shape_field_name": this._es.attribute,
                    "id": this._es.parent.id,
                    "type": this._es.type,
                    "index": this._es.index
                  }
                }
              }
            }
          }
        }
      };
      console.log(ne.url());
      console.log(es.get('properties'));
      return ne.fetch({
        success: function(collection, response, options) {
          var model, _i, _len, _ref3, _results;
          console.log('success');
          console.log('model', ne.total, ne.took);
          _ref3 = ne.models;
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            model = _ref3[_i];
            _results.push(console.log('model', ne.total, ne.took, model.get('properties')));
          }
          return _results;
        },
        error: function(collection, response, options) {
          return console.log('error', response);
        }
      });
    };

    return GeoShape;

  })(Elasticbone.ElasticsearchType);

  if (typeof define !== 'undefined' && define.amd) {
    define([], function() {
      return Elasticbone;
    });
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = Elasticbone;
  }

}).call(this);
