// Generated by CoffeeScript 1.6.1
(function() {
  var $, Backbone, Elasticbone, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Elasticbone = {};

  $ = require('jquery');

  _ = require('backbone/node_modules/underscore');

  Backbone = require('backbone');

  Backbone.$ = $;

  Elasticbone.Backbone = Backbone;

  Elasticbone.$ = $;

  Elasticbone._ = _;

  $.wait = function(time) {
    return $.Deferred(function(dfd) {
      return setTimeout(dfd.resolve, time);
    });
  };

  Elasticbone.ElasticModel = (function(_super) {

    __extends(ElasticModel, _super);

    ElasticModel.prototype.urlRoot = function() {
      return "" + this.server + "/" + this.index + "/" + this.type;
    };

    function ElasticModel() {
      this.type = this.constructor.name;
      ElasticModel.__super__.constructor.apply(this, arguments);
    }

    ElasticModel.has = function(name, model, options) {
      var _base;
      if (options == null) {
        options = {};
      }
      options = _.defaults(options, {
        method: 'parse',
        model: model,
        name: name
      });
      (_base = this.prototype)._has || (_base._has = {});
      return this.prototype._has[name] = options;
    };

    ElasticModel.prototype.has_relationship = function(attr, options) {
      return this.get_relationship(attr, options) && true;
    };

    ElasticModel.prototype.get_relationship = function(attr, options) {
      var has_rel;
      if (options == null) {
        options = {};
      }
      has_rel = this._has && this._has[attr] && true;
      if (options.method) {
        has_rel = has_rel && options.method === this._has[attr].method;
      }
      if (!has_rel) {
        return void 0;
      }
      return this._has[attr];
    };

    ElasticModel.prototype.get_relationship_model = function(attr) {
      return this.get_relationship(attr).model;
    };

    ElasticModel.prototype.get_relationship_method = function(attr) {
      return this.get_relationship(attr).method;
    };

    ElasticModel.prototype.get_relationship_reverse = function(attr) {
      return this._has[attr].reverse;
    };

    ElasticModel.prototype.has_relationship_reverse = function(attr) {
      return !!this._has[attr].reverse;
    };

    ElasticModel.prototype.get_relationships = function(options) {
      var key, rel, rels, val, _ref;
      if (options == null) {
        options = {};
      }
      if (!this._has) {
        return [];
      }
      rels = [];
      _ref = this._has;
      for (key in _ref) {
        val = _ref[key];
        if ((rel = this.get_relationship(key, options))) {
          rels.push(rel);
        }
      }
      return rels;
    };

    ElasticModel.prototype.set_model_values = function(m, attr) {
      if (this.has_relationship_reverse(attr)) {
        m.set(this.get_relationship_reverse(attr), this);
      }
      m._parent = this;
      return m._field_name = attr;
    };

    ElasticModel.prototype.get = function(attr, options) {
      var data, m, model_class;
      data = ElasticModel.__super__.get.call(this, attr, options);
      if (data) {
        return $.when(data);
      }
      if (this.has_relationship(attr, {
        method: 'fetch'
      })) {
        model_class = this.get_relationship_model(attr);
        m = new model_class();
        this.set_model_values(m, attr);
        this.set(attr, m);
        return $.when(m.fetch(options)).then(function(res) {
          return m;
        });
      }
      return $.when(void 0);
    };

    ElasticModel.prototype.parse = function(data, options) {
      var m, parsed, val, _i, _len, _ref;
      data = ElasticModel.__super__.parse.call(this, data, options);
      parsed = {};
      if (data._id) {
        parsed.id = data._id;
      }
      if (data.id) {
        parsed.id = data.id;
      }
      if (data.ok) {
        return parsed;
      }
      if (data._source) {
        parsed = _.extend(parsed, data._source);
      } else {
        parsed = _.extend(parsed, data);
      }
      _ref = this.get_relationships();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        val = _ref[_i];
        if (parsed[val.name]) {
          m = new val.model(parsed[val.name], {
            parse: true
          });
          this.set_model_values(m, val.name);
          parsed[val.name] = m;
        }
      }
      return parsed;
    };

    ElasticModel.prototype.toJSON = function(options) {
      var json, rel, _i, _j, _len, _len1, _ref, _ref1;
      json = ElasticModel.__super__.toJSON.apply(this, arguments);
      delete json.id;
      _ref = this.get_relationships();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rel = _ref[_i];
        delete json[rel.name];
      }
      _ref1 = this.get_relationships({
        method: 'parse'
      });
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        rel = _ref1[_j];
        this.get(rel.name).done(function(x) {
          if (x) {
            return json[rel.name] = x.toJSON(options);
          }
        });
      }
      return json;
    };

    return ElasticModel;

  })(Backbone.Model);

  Elasticbone.ElasticCollection = (function(_super) {

    __extends(ElasticCollection, _super);

    function ElasticCollection() {
      return ElasticCollection.__super__.constructor.apply(this, arguments);
    }

    ElasticCollection.prototype.fetch_query = function() {
      return {
        "query": {
          "match_all": {}
        }
      };
    };

    ElasticCollection.prototype.url = function() {
      var u;
      u = "" + this.server;
      if (this.index) {
        u += "/" + this.index;
        if (this.type) {
          u += "/" + this.type;
        }
      }
      u += "/_search?size=100";
      return u;
    };

    ElasticCollection.prototype.model = Elasticbone.ElasticsearchObject;

    ElasticCollection.prototype.server = 'http://localhost:9200';

    ElasticCollection.prototype.parse = function(data) {
      this.total = data.hits.total;
      this.took = data.took;
      return data.hits.hits;
    };

    ElasticCollection.prototype.fetch = function(options) {
      return ElasticCollection.__super__.fetch.call(this, _.defaults(options, {
        type: 'POST',
        data: JSON.stringify(this.fetch_query())
      }));
    };

    ElasticCollection.prototype.set_reverse = function(attr, model) {
      return this[attr] = model;
    };

    return ElasticCollection;

  })(Backbone.Collection);

  Elasticbone.GeoQuery = (function() {

    function GeoQuery() {}

    GeoQuery.find_intersecting = function(geoshape, elasticbone_collection, field) {
      var ebc, geo_shape_query;
      ebc = new elasticbone_collection();
      if (!!(geoshape._field_name && geoshape._parent.id && geoshape._parent.type && geoshape._parent.index)) {
        geo_shape_query = this.query_from_cached(field, geoshape._field_name, geoshape._parent.id, geoshape._parent.type, geoshape._parent.index);
      } else {
        geo_shape_query = this.query_from_geojson(field, geoshape.toJSON());
      }
      return $.when(ebc.fetch({
        data: JSON.stringify(geo_shape_query)
      })).then(function(res) {
        return ebc;
      });
    };

    GeoQuery.query_from_cached = function(query_field, shape_field_name, id, type, index) {
      return {
        "query": {
          "filtered": {
            "query": {
              "match_all": {}
            },
            "filter": {
              "geo_shape": {
                query_field: {
                  "indexed_shape": {
                    "shape_field_name": shape_field_name,
                    "id": id,
                    "type": type,
                    "index": index
                  }
                }
              }
            }
          }
        }
      };
    };

    GeoQuery.query_from_geojson = function(query_field, geojson) {
      return {
        "query": {
          "filtered": {
            "query": {
              "match_all": {}
            },
            "filter": {
              "geo_shape": {
                query_field: {
                  "shape": geojson
                }
              }
            }
          }
        }
      };
    };

    return GeoQuery;

  })();

  Elasticbone.GeoShape = (function(_super) {

    __extends(GeoShape, _super);

    function GeoShape() {
      return GeoShape.__super__.constructor.apply(this, arguments);
    }

    return GeoShape;

  })(Backbone.Model);

  if (typeof define !== 'undefined' && define.amd) {
    define([], function() {
      return Elasticbone;
    });
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = Elasticbone;
  }

}).call(this);
